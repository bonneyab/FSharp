namespace FSharpEulerProblems
open System

//Multiples of 3 and 5
//Problem 1
//If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
//Find the sum of all the multiples of 3 or 5 below 1000.
module Problem1 =
  let GetSumOfMultiplesBelowNumber multiples number = 
    [1..number-1] |> List.filter(fun o -> multiples |> Seq.exists(fun n -> o % n = 0)) |> List.sum

//Even Fibonacci numbers
//Problem 2
//Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
//
//1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
//
//By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
module Problem2 =
  let FibonacciGetSumBelowMax max =
    let rec fibonacciSumBelowMaxInner prev current total =
      match (prev + current), max with
        | next, max when next > max -> total
        | next, _ when next % 2 = 0 -> fibonacciSumBelowMaxInner current next (total + next)
        | next, _ -> fibonacciSumBelowMaxInner current next total
    fibonacciSumBelowMaxInner 0 1 0
  
//Not my solution but I really liked this one...need to understand how infinite sequences work, probably not used a lot but interesting
  let InfiniteSequenceMethod max =
    let fibSeq = (1,1) |> Seq.unfold (fun (a, b) -> Some(a+b, (b, a+b)) )
    fibSeq |> Seq.takeWhile (fun x -> x <= max) |> Seq.sumBy (fun x -> if x%2 = 0 then x else 0)

//Largest prime factor
//Problem 3
//The prime factors of 13195 are 5, 7, 13 and 29.
//What is the largest prime factor of the number 600851475143 ?
module Problem3 =
  //I know there's faster ways but this reads nice and clean...
  let GetLargetPrimeFactor number = 
    let rec GetLargetPrimeFactorRecursive num max current =
      match num with
        | x when x < current -> max
        | x when x % current = 0 -> GetLargetPrimeFactorRecursive (num/current) current (current + 1)
        | x -> GetLargetPrimeFactorRecursive num max (current + 1)
    GetLargetPrimeFactorRecursive number 1 2

//Largest palindrome product
//Problem 4
//A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
//Find the largest palindrome made from the product of two 3-digit numbers.
module Problem4 =
  let GetLargestPalindromeProduct number = 
    let isPalindrome s =
      new string(Array.rev(s.ToString().ToCharArray())) = s.ToString()
    let rec rc left right current mark =
      let next = right * left
      match left, right, next with
        | a, b, c when a < 1 || a < mark -> current
        | a, b, c when isPalindrome(c) && c > current -> rc (a - 1) number c b
        | a, b, c when b > 0 -> rc a (b - 1) current mark
        | a, b, c -> rc (a - 1) number current mark
    rc number number 0 0

////Smallest multiple
////Problem 5
////2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
////What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
module Problem5 =
  let getSmallestNumberDivisibleByNumbers maxNumber = 
    let getPrimeFactors(n : int) = 
      let rec getPrimFactorsInner number divisor factors =
        match number, divisor with
          | n, d when n < d -> factors
          | n, d when n % d = 0 -> getPrimFactorsInner (n/d) d (d :: factors)
          | n, d -> getPrimFactorsInner n (d + 1) factors
      getPrimFactorsInner n 2 []

    let factors = 
      [2..maxNumber] 
        |> List.map(fun x -> getPrimeFactors x )
        |> Seq.map(fun x -> x |> Seq.countBy id ) 
        |> Seq.concat
        |> Seq.groupBy fst
        |> Seq.map(fun(k, v) -> v |> Seq.max)

    //This is the same
//    let blackMagic = 
//      List.map(fun x -> getPrimeFactors x ) 
//      >> Seq.map(fun x -> x |> Seq.countBy id ) 
//      >> Seq.concat 
//      >> Seq.groupBy fst 
//      >> Seq.map(fun(k, v) -> v |> Seq.max)
//    let factors2 = [2..maxNumber] |> blackMagic
//    let factors2 = blackMagic [2..maxNumber]

    //This is the same too...but awful
    //So this is pretty much why you have the dot syntax in C# for linq I guess
    //let test = Seq.map(fun(k, v) -> v |> Seq.max) (Seq.concat (Seq.groupBy fst (Seq.map(fun x -> x |> Seq.countBy id )  (List.map(fun x -> getPrimeFactors x ) [2..maxNumber]))))

    let powerify(k: int, v: int) = int <| Math.Pow(float k, float v)
    factors |> Seq.fold(fun state factor -> state * powerify factor) 1

//The sum of the squares of the first ten natural numbers is,
//12 + 22 + ... + 102 = 385
//The square of the sum of the first ten natural numbers is,
//(1 + 2 + ... + 10)2 = 552 = 3025
//Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 − 385 = 2640.
//Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
module Problem6 = 
  let sumSquaresSquareSumsDifference num = 
    let sumOfSquares = [1..num] |> Seq.map(fun x -> Math.Pow(float x, float 2) |> int) |> Seq.sum
    let square x = Math.Pow(float x, float 2) 
    let squareOfSums = ([1..num] |> Seq.sum) |> square |> int
    Math.Abs(squareOfSums - sumOfSquares) |> int

//10001st prime
//Problem 7
//By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
//What is the 10 001st prime number?
module Problem7 = 
  //Trying to do this without recursion...
  let getSpecificPrime nthPrime =
    let isPrime num = 
      let max = Math.Sqrt(float num) |> int
      not([2..max] |> Seq.exists(fun x -> num % x = 0))

    //skipping to and doing it by 2's to save some iterations, adding 2 at the end.
    let primes = 
      Seq.unfold(fun x -> Some(x, x + 2)) 3 
        |> Seq.filter isPrime 
        |> Seq.append [2]
    
    //The same! (but starts at 1 and doesn't do 2; you get the idea...)
    //let primes = Seq.initInfinite (fun i -> i + 2) |> Seq.filter isPrime
    //printfn "%A" primes
    primes |> Seq.take nthPrime |> Seq.last


//Find the greatest product of five consecutive digits in the 1000-digit number. 
//73167176531330624919225119674426574742355349194934
//96983520312774506326239578318016984801869478851843
//85861560789112949495459501737958331952853208805511
//12540698747158523863050715693290963295227443043557
//66896648950445244523161731856403098711121722383113
//62229893423380308135336276614282806444486645238749
//30358907296290491560440772390713810515859307960866
//70172427121883998797908792274921901699720888093776
//65727333001053367881220235421809751254540594752243
//52584907711670556013604839586446706324415722155397
//53697817977846174064955149290862569321978468622482
//83972241375657056057490261407972968652414535100474
//82166370484403199890008895243450658541227588666881
//16427171479924442928230863465674813919123162824586
//17866458359124566529476545682848912883142607690042
//24219022671055626321111109370544217506941658960408
//07198403850962455444362981230987879927244284909188
//84580156166097919133875499200524063689912560717606
//05886116467109405077541002256983155200055935729725
//71636269561882670428252483600823257530420752963450
module Problem8 = 
  let getMaxMultipleFromStringNumber(num : string) =
    //char directly to int doesn't actually give you the digit value.
    let numbers = num.ToCharArray() |> Array.map(fun x -> x |> string) |> Array.toList |> List.map(fun x -> x |> int)
    let returnMax oldTotal seq =
      let newTotal = seq |> Seq.take(5) |> Seq.fold (*) 1
      let tail = seq |> List.tail
      if newTotal > oldTotal then (newTotal, tail) else (oldTotal, tail)
    
    //Alright, initial numbers is really just used for the total number of iterations, we skip 4 so that there are always 5 to take
    //This is really a fancy way of avoiding a normal recursive call by using the second part of the tuple to maintain the tail of the list
    //I suppose I've generally tried to avoid normal recursion and loops but this is probably a step too far considering a recursive sort of
    //call is pretty straightforward
    //Sort of interesting though so leaving it
    let max = numbers |> Seq.skip(5) |> Seq.fold(fun (total, seq) item -> returnMax total seq) (0, numbers)
    fst max


//  A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,
//a^2 + b^2 = c^2
//For example, 32 + 42 = 9 + 16 = 25 = 5^2.
//There exists exactly one Pythagorean triplet for which a + b + c = 1000.
//Find the product abc. Test
module Problem9 =
  let getProductOfPythagoreanTripletForNumber(num : int) =
    let increment triplet =
      match triplet with
        | (a, b, c) when a + 1 < b - 1 -> (a + 1, b - 1, c)
        | (a, b, c) when num - c + 1 >= c - 1 -> (num - (c * 2 - 3), (c - 2), (c - 1))
        | (a, b, c) -> (0, num - c + 1, c - 1)

    let rec innerTripletForNumber triplet =
      //printfn "%A" triplet
      match triplet with
        | (a, b, c) when a >= b -> 0
        | (a, b, c) when Math.Pow(float a, float 2) + Math.Pow(float b, float 2) = Math.Pow(float c, float 2) -> a * b * c
        | (a, b, c) -> innerTripletForNumber (increment triplet)
    innerTripletForNumber (0, 1, num - 1)

// Highly divisible triangular number
// Problem 12
// The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
// 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
// Let us list the factors of the first seven triangle numbers:
//  1: 1
//  3: 1,3
//  6: 1,2,3,6
// 10: 1,2,5,10
// 15: 1,3,5,15
// 21: 1,3,7,21
// 28: 1,2,4,7,14,28
// We can see that 28 is the first triangle number to have over five divisors.
// What is the value of the first triangle number to have over five hundred divisors?

//While functional, this is far too slow, consider some sort of prime seive then generating factors or storing all the previously calculated numbers.
module Problem12 =
    let getFirstTriangleNumberWithNumberOfDivisors numberOfDivisors =
        let getTriangleNumber num = num * (num + 1)/2
        //Probably doesn't need the +1
        let getDivisors max = max :: ([1..(max/2)] |> List.filter(fun x -> max % x = 0))

        let rec inner num =
            let triangleNumber = getTriangleNumber(num)
            if(getDivisors(triangleNumber).Length > numberOfDivisors) 
                then triangleNumber 
                else inner (num + 1)

        inner(1)


// Longest Collatz sequence
// Problem 14
// The following iterative sequence is defined for the set of positive integers:
// n → n/2 (n is even)
// n → 3n + 1 (n is odd)
// Using the rule above and starting with 13, we generate the following sequence:
// 13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1
// It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms. Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at 1.
// Which starting number, under one million, produces the longest chain?
// NOTE: Once the chain starts the terms are allowed to go above one million.
//object Problem14 {
//  var _computedValues = new mutable.HashMap[BigInt, Int]
//  def getLongestCollatzSequenceUnderNumber(number: Int) : Int = {
//    ((1, 1) /: (number to 1 by -1)) ((i, m) => 
//        getCollatzTermLength(m) match {
//          case x if x > i._1 => (x, m)
//          case _ => i
//        }
//      )._2
//  }
//
//  @tailrec def getCollatzTermLength(number: BigInt, total: Int = 1) : Int = {
//    if(_computedValues.contains(number)){
//        _computedValues.put(number, (total - 1 + _computedValues(number)))
//        return total - 1 + _computedValues(number)
//    }
//    number match {
//      case x if x == 1 => total
//      case x if x % 2 == 0 => getCollatzTermLength(x/2, total + 1)
//      case x => getCollatzTermLength(x * 3 + 1, total + 1)
//    }
//  }
//}

module Problem14 =
    let getLongestCollatzSequenceUnderNumber number = 
        //[number..1] |> 
        5
    
    let rec getCollatzTermLength number total =
        match number with 
        | i when i = 1 -> total
        | i when i % 2 = 0 -> getCollatzTermLength (i/2) (total + 1)
        | i -> getCollatzTermLength (i * 3 + 1) (total + 1)


//Double-base palindromes
//Problem 36
//The decimal number, 585 = 10010010012 (binary), is palindromic in both bases.
//Find the sum of all numbers, less than one million, which are palindromic in base 10 and base 2.
//(Please note that the palindromic number, in either base, may not include leading zeros.)
module Problem36 =
    let isDoubleBasedPalindrome number =
        let isPalindrome(text:string) = 
            (text.ToCharArray() |> Array.rev |> System.String.Concat) = text
        (isPalindrome(number.ToString()) && isPalindrome(Convert.ToString((number:int), 2)))

    let getDoubleBasePalindromesUnderNumberSum number = 
        [1..number] |> Seq.filter isDoubleBasedPalindrome |> Seq.sum
        